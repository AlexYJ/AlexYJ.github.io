 
## DOM(Document Object Model)
- 객체 지향 모델
- 구조화된 문서를 표현하는 형식
- 동적으로 문서의 내용, 구조, 스타일에 접근하고 변경하는 수단
- 잘 구조회된 문서는 DOM으로 Tree 구조를 얻어낼 수 있다
- 문서 요소가 임의적으로 접근되고 변경할 수 있어야 하는 응용 프로그램에 가장 적합

## PWA(progerssive web app)
- 앱 수준으로 점진적으로 발전해 나가는 웹
- 궁극적으로는 앱 수준과 같은 사용자 경험을 웹에서 제공하는 것이 목적
### 특징
- 안정성 : 불안한 네트워크 환경에서도 PWA는 안정적으로 동작해야 함
- 빠른 속도 : 사용자 인터렉션에 빠르고 부드럽게 반응해야 함
- 관여 : 진짜 앱처럼 몰입감 높은 사용자 경험을 제공해야 
 


## DB 클러스터링과 리플리케이션의 차이점
클러스터링은  DB서버를 다중화 하는 것이고 리플리케이션은 서버와 데이터를 같이 다중화 하는 것

## View vs Table
### View
- 물리적인 테이블을 근거한 논리적인 가상테이블.
- 사용자가 해당 View에 접근하면 그때 View에 들어있던 SQL이 수행되어 결과를 가져옴
- 뷰는 물리적으로 데이터를 저장하지 않고, 쿼리문장 자체를 저장.
- 복잡하고 긴 쿼리문을 뷰로 정의하면 접근을 단순화 할 수 있음.
### Table
- 실질적인 데이터를 저장하는 물리적인 테이블.


## Call by value, Call by reference
a = 10; b = a; 라고 하면 b는 10이 들어가는게 아니고 a의 주소가 복사가 된다. 그래서 b를 수정하면 a에도 영향을 미치는게 call by reference
call by value 는 a = 10; b = a; 했을 때 b = 10이 된다. b를 수정해도 a에 영향을 주지 않는다.

## JVM
### JVM 구조
#### Method(Static) Area
class의 구조 정보가 들어간다.
#### Stack Area
Method정보, 메소드 호출 시 사용하는 지역변수 데이터 등을 저장한다. {}가 끝나는 동안 유지된다.
JVM시작시 생성되고 프로그램이 종료될때까지 유지된다.
#### Heap Area
new 를 한게 여기로 들어감 gc의 주요 대상이다
- Young Generation: 이 영역은 자바 객체가 생성되자마자 저장되고, 생긴지 얼마 안되는 객체가 저장되는 공간이다. 시간이 지나 우선순위가 낮아지면 Old 영역으로 옮겨진다. 이 영역에서 객체가 사라질 때 Minor GC가 발생한다.
- Old(Tenured) Generation: Young Generation 영역에서 저장되었던 객체 중에 오래된 객체가 이동되어 저장되는 영역이다. 이 영역에서 객체가 사라질 때 Major GC(Full GC)가 발생한다.
- Permanent Generation: 클래스 로더에 의해 로든되는 클래스, 메소드 등에 대한 메타 정보가 저장되는 영역으로 JVM에 의해 사용된다. 리플렉션을 사용하여 동적으로 클래스가 로딩되는 경우에 사용된다. 내부적으로 리플렉션 기능을 자주 사용하는 Spring Framework를 이용할 경우 이 영역에 대한 고려가 필요하다.


### JVM 왜 쓰는가?
멀티플랫폼을 지원하기 위해 고안된 기술, OS 위에서 JVM 이 동작하여 다양한 디바이스에서 동일코드로 동일결과를 만들기위함이 베이스가 되어 만들어진 기술
### JVM GC 구조


## restFul API와 SOAP에 대해 각각 설명하고 차이점을 말하세요.

-SOAP(Simple Object Access Protocol)
HTTP프로토콜 위에서 XML로 통신한다.

-Restful API(Representational State Transfer)
HTTP를 통해 CRUD를 실행하는 API

## 웹 공격 패턴과 방어 방법에 대해 설명 해보세요.

1.sql 인젝션 공격
- 웹의 취약점을 이용해 개발자가 예상하지 못한 sql이 실행 되도록 하는 공격. 예를 들면 물건에 입금이 안되었는데 입금 처리 필드를 0에서 1로 바꾸는 등.
막는 방법은 값을 검사해서 해당 값만 들어갈 수 있게 한다. 예를들어 숫자만 가능하게 한다던지 이메일 필드는 해당 패턴만 가능하게 한다던지 등.

2.CSRF크로스 사이트 스크립트 공격
3.리퀘스트 변조
- admin page기능을 회사 사람이 아닌 해커가 호출을 하는 경우이다. 보안 token을 발행하여 해당 토큰이 없으면 액세스 하지 못하게 막는다.

## 응답코드
### 응답코드 200
("OK") 모든 과정이 잘 처리되었다. body가 있을 경우 리소스를 표현하는 것이다.
### 응답코드 201
("Created") 새로운 리소스가 생성되었다. location 헤더는 리소스를 가르키는 URI를 포함하고 있어야 하고 body는 새로 생성된 리소스의 대표값을 가진다.
### 응답코드 204
("No Content") 서버가 어떠한 상태 메세지를 보내기를 거부하였다.
### 응답코드 400
("Bad Request") 클라이언트에서 문제가 발생했다. body가 에러 메세지이다.
### 응답코드 401
("Unauthorized") 클라이언트가 요청한 리소스에 대한 적절한 인증 조건을 만족하지 못하였다.
### 응답코드 404
("Not Found") 클라이언트가 어떠한 리소스에도 해당하지 않는 URI를 요청했다.
### 응답코드 500
("Internal Server Error") 서버에서 문제가 발생하였다. body는 에러 메세지이다.


## Ajax
### Ajax 란
JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술
### Ajax 장단점
#### Ajax의 장점
1. 웹페이지의 속도향상
2. 서버의 처리가 완료 될때까지 기다리지 않고 처리 가능하다.
3. 서버에서 Data만 전송해면 되므로 전체적인 코딩의 양이 줄어든다.
4. 기존 웹에서는 불가능했던 다양한 UI를 가능하게 해준다. 사진공유 사이트 Flickr의 경우 사진의 제목이나 태그를 페이지 리로드 없이 수정할 수 있다.

#### Ajax 의 단점
1. 히스토리 관리가 안 된다. (보안에 좀 더 신경을 써야한다.)
2. 연속으로 데이터를 요청하면 서버 부하가 증가할 수 있다.
3. XMLHttpRequest를 통해 통신을 하는 경우사용자에게 아무런 진행 정보가 주어지지 않는다. 그래서 아직 요청이 완료되지 않았는데 사용자가 페이지를 떠나거나 오작동할 우려가 발생하게 된다. 


## C#
### string과 StringBuffer의 차이점에 대해서 설명해주세요. 
- string 클래스는 변경이 불가능한 immutable 클래스이고,
- stringBuffer 클래스는 변경이 가능한 mutable 클래스이다.

### using 이라는 키워드는 네임스페이스를 링크하기 위해서 사용하기도 하지만 객체를 생성할 때 또한 사용되기도 합니다. 이때 using을 이용하는 목적에 대해서 설명해주세요.

- 일반적으로 객체를 생성할 경우 메모리에 데이터가 올라가고 메모리 자원관리를 위해 객체 사용이 끝난 다음에 DIspose()를 해주어야 합니다. using문을 사용해서 객체를 사용하면 using문의 {}를 벗어나면 객체에 관련된 자원(혹은 객체에서 사용한 자원)이 자동으로 해제되며 예외 발생시에도 자원을 해제해줍니다.
- 참고 : IDispoable 인터페이스를 구현한 객체만 using문을 사용할 수 있습니다.

###  객체를 만들 때 메모리 해제를 위해서 일반적으로 IDisposable 인터페이스를 상속받아서 처리하게 되는 경우가 많습니다. 닷넷에서의 소멸자는 Dispose(), Finalize()가 존재하는데 이 두 가지의 차이점은 무엇인지 기술해주세요.

#### Dispose는 더이상 객체 사용이 불필요한 경우 명시적 제어
- 명시적으로 해제되어야 하는 리소스를 캡슐화하는 형식에 대해 dispose 디자인 패턴을 구현합니다. 사용자는 공용 Dispose 메서드를 호출하여 외부 리소스를 해제할 수 있습니다.
- 일반적으로 기본 형식에 리소스를 계속 사용하는 파생 형식이 있으면 기본 형식에서는 리소스를 계속 사용하지 않더라도 해당 기본 형식에 대해 dispose 디자인 패턴을 구현합니다. 기본 형식에 Close 메서드가 있으면 이는 대개 Dispose를 구현해야 함을 나타냅니다. 이런 경우에는 기본 형식에 대해 Finalize 메서드를 구현하지 않습니다. Finalize는 정리가 필요한 리소스를 사용하는 파생 형식에서 구현되어야 합니다.
- 형식이 소유하는 삭제 가능한 모든 리소스는 해당 Dispose 메서드에서 해제합니다.
- 인스턴스에 대해 Dispose를 호출한 후에는 GC.SuppressFinalize 메서드를 호출하여 Finalize 메서드가 실행되지 않도록 합니다. 드물지만Dispose에서 다루지 않는 작업을 Finalize에서 수행해야 하는 경우에는 이 규칙이 적용되지 않습니다.
- 기본 클래스에서 IDisposable을 구현하면 기본 클래스의 Dispose 메서드를 호출합니다.
- Dispose가 호출될 것으로 가정하지 않습니다. 형식에서 소유하는 관리되지 않는 리소스는 Dispose가 호출되지 않는 경우 Finalize 메서드에서도 해제되어야 합니다.
- 리소스가 이미 삭제되었을 때 해당 형식(Dispose 제외)에 대한 인스턴스 메서드에서 ObjectDisposedException을 throw합니다. Dispose 메서드는 예외를 throw하지 않고 여러 번 호출할 수 있으므로 이 규칙이 적용되지 않습니다.
- 기본 형식의 계층 구조를 통해 Dispose에 대한 호출을 전파합니다. Dispose 메서드는 해당 개체와 해당 개체 소유의 모든 개체에서 사용하는 리소스를 모두 해제해야 합니다. 예를 들어, 사용자가 모르는 사이에 TextReader에 의해 만들어지는 Stream과 Encoding을 계속 사용하는 TextReader 등의 개체를 만들 수 있습니다. 또한 Stream과 Encoding은 모두 외부 리소스를 받아 들일 수 있습니다. TextReader에 대해Dispose 메서드를 호출하면 해당 개체는 Stream과 Encoding에 대해 Dispose를 호출하여 해당 외부 리소스를 해제하도록 합니다.
- Dispose 메서드가 호출된 다음에는 개체를 다시 사용할 수 없도록 하는 것이 좋습니다. 이미 삭제된 개체를 다시 만드는 것은 구현하기 어려운 패턴입니다.
- Dispose 메서드는 예외를 throw하지 않고 한 번 이상 호출될 수 있도록 합니다. 이 메서드는 처음 호출된 이후에는 아무 작업도 수행하지 않습니다.


#### Finalize는 프로그래머가 Dispose 호출에 실패하는 경우 리소스가 누수되지 않도록 백업 기능 제공
- 기본 클래스의 Finalize 메서드는 C# 및 C++ 소멸자 구문을 사용하여 자동으로 호출됩니다.
- 종료가 필요한 개체에 대해서만 Finalize를 구현. Finalize 메서드를 구현하면 성능이 저하될 수 있습니다.
- Finalize 메서드가 필요하면 클래스 사용자가 Finalize 메서드를 호출할 필요가 없도록 IDisposable을 구현할 것인지 고려
- Finalize 메서드를 보다가 가시적인 메서드로 만들지 않습니다. 이 메서드는 protected여야 합니다.
- 개체의 Finalize메서드는 해당 개체가 소유하는 모든 외부 리소스를 해제해야 합니다. 또한 Finalize메서드는         
- 해당 개체에서 보유한 리소스만 해제해야 합니다. Finalize 메서드는 다른개체를 참조하지 않습니다.
- 해당 개체의 기본 클래스가 아닌 개체에 대해 Finalize 메서드를 직접 호출하지 않습니다.
- 개체의 Finalize 메서드에서 기본 클래스의 Finalize 메서드를 호출합니다.

### C# 데이터 타입은 값 타입, 참조 타입이 있음.
- 값 형식 : 값을 변수에 넣는 데이터 형식. 스택에 저장. 
  스택메모리를 미용하면 변수가 할당 된 위치의 값만 변경됨. LIFO방식. 해제시점은 변수선언 영역을 벗어날 때.
- 참조 형식 : 변수에 대한 위치(메모리 위치)를 담는 데이터 형식. 값이 복사가 아니라 주소가 복사됨. 
  스택에는 메모리 주소가, 힙에는 실질적인 값이 저장. 새로운 객체변수에 기존 변수 할당하면 스택의 메모리 주소만 복사. 값을 변경하면 참조하고 있는 모든 변수의 값이 동일해짐. 힙메모리 영역 해제시점은 알 수 없음.

### 접근 권한자
- public : 모든 외부 객체로부터 접근을 허용한다
- protected : 상속되는 파생클래스(derived class)에서만 접근할 수 있다
- private : 해당 클래스 내에서만 사용된다. 외부 혹은 파생클래스에서 접근 불가
- internal : 어셈블리(.NET Assembly)내에 있는 다른 클래스들에서 접근할 수 있다
- protected internal : 액세스가 현재 어셈블리 또는 포함하는 클래스에서 파생된 형식으로 제한됩니다.
- private protected : 액세스가 포함하는 클래스 또는 현재 어셈블리 내의 포함하는 클래스에서 파생된 형식으로 제한됩니다. C# 7.2부터 사용할 수 있습니다.

### ASP vs ASP.NET 차이점
- ASP는 인터프리터 방식. VB언어 기반 스크립트 방식. IIS상에서 운영.
- ASP.NET은 컴파일러 방식. 닷넷 언어 기반 개발. IIS, .NET Framework 에서 운영.

### ArrayList vs LinkedList
#### ArrayList
- 자료형에 무관하다. ( = 유형이 다른 컬렉션을 보관할 수 있다.  = List<Object> 와 같다. )
- 이 때 모든 자료형은 암시적으로 Object로 업캐스팅 되기 때문에, boxing, unboxing 과정때매 성능이 구리다.
- 배열과 같이 index로 direct access가 가능하다. ( O(1) time )
- LinkedList처럼 IEnumerable 인터페이스를 구현했기 때문에 foreach에서와 같이 iterator 사용이 가능하다.

#### LinkedList
- Linked List 자료구조이다.
- Generic의 장점으로 컴파일 타임에 형식을 감지 할 수 있기 때문에 타입에 맞지 않는 메서드가 실행될 수 있는 위험을 방지할 수 있다. ( 프로그램 오류의 확률 줄어듬 )
- 정해진 제네릭 타입에 관한 자료구조이기 때문에, ArrayList에 비해 속도가 빠르다.

### WebForm vs MVC
#### WebForm
웹폼은 Page Controller 패턴에 기반한 모델. 페이지라는 개념을 중심에 두고 사용자 인터페이스를 다루는데 초점이 있다. 따라서, 페이지가 입력을 받고, 또 제출(포스트백해서 저장)하고 브라우저에게 보내는 응답까지 결정한다. 컨트롤을 드래그앤드랍하여 코드 비하인드에서 몇줄 코딩으로 완벽한 기능을 구현할 수 있다.
- 장점
1. Control의 삽입이 빠르다
2. 이벤트 중심이어서 해당 에빈트를 작성하는 것만으로도 빠르게 사용자 요청을 처리할 수 있다.
3. 한 페이지에 많은 기능을 빠른 시간내에 삽입할 수 있다.

- 단점
1. 프로젝트를 구성하는 아키텍쳐가 약해 유지보수하기 어렵다. 
2. 이벤트 드리븐 방식의 코딩패턴은 전체 흐름을 파악하기 불편
3. 테스트 자동화가 어렵다. 단단하게 꽉 묶여진 하나의 런타임 환경에서 돌아가는데, 이 환경이 테스트 모듈과 얘기하면서 돌아갈만큼 유연하지 않음.

#### MVC
MVC는 Model-View-Controller에 기반하여 SOC(Seperation of Concerns)가 자연스럽게 되는 구조를 갖고 있음. 
코드의 잴활용도가 높고 깔끔한 프로젝트 구조로 유지보수와 확장을 쉽게해줌.

- __Model__ : 프로그램에서 사용되는 실제 데이터 및 데이터 조작 로직을 처리하는 부분
- __View__ : 사용자에게 제공되어 보여지는 UI부분
- __Controller__ : 사용자의 입력을 받고 처리하는 부분

![](https://magi82.github.io/images/2017-2-24-android-mvc-mvp-mvvm/mvc.png)

- 장점
1. Url Routing이 자동적으로 지원되어 사용자 친화 URL을 만들기 용이
2. ViewState가 없기 때문에 가볍다.
3.페이지별로 Controller가 존재하던 웹폼과 달리 모든 코드가 Method형태로 되어있어 단위 테스트에 강하다.

- 단점
View와 Model이 서로 의존적.

#### MVP
MVP는 Model-View-Presenter. Model과 View는 MVC와 동일하지만 사용자 입력을 View에서 받음. 그리고 Model과 View는 각각 Presenter와 상호 동작을 하게 됨. 항상 Presenter을 거쳐서 동작. 

- __Presenter__ : View에서 요청한 정보를 Model로 부터 가공해서 View로 전달하는 부분
![](https://magi82.github.io/images/2017-2-24-android-mvc-mvp-mvvm/mvp.png)

1. View로 사용자의 입력이 들어옵니다.
2. View는 Presenter에 작업 요청을 합니다.
3. Presenter에서 필요한 데이터를 Model에 요청 합니다.
4. Model은 Presenter에 필요한 데이터를 응답 합니다.
5. Presenter는 View에 데이터를 응답 합니다.
6. View는 Presenter로부터 받은 데이터로 화면에 보여주게 됩니다.

- 장점
View와 Model의 의존성이 없어지게 됨.

- 단점
View와 Presenter가 1:1로 강한 의존성을 가지게 됨


#### MVVM
MVVM은 Model-View-ViewModel. MVVM은 WPF나 SilverLight에서 많이 사용되는 프레임워크 패턴.
MVVM은 두가지 디자인 패턴을 사용합니다. 바로 Command패턴과 Data Binding 인데요.
이 두가지 패턴으로 인해 View와 ViewModel은 의존성이 완전히 사라지게 됩니다.
MVP와 마찬가지로 View에서 입력이 들어오구요. 입력이 들어오면 Command 패턴을 통해 ViewModel에 명령을 내리게 되고 Data Binding으로 인해 ViewModel의 값이 변화하면 바로 View의 정보가 바뀌어져 버리게 됩니다.

- __ViewModel__ : View를 표현하기 위해 만들어진 View를 위한 Model
![](https://magi82.github.io/images/2017-2-24-android-mvc-mvp-mvvm/mvvm.png)

1. View에 입력이 들어오면 Command 패턴으로 ViewModel에 명령을 합니다.
2. ViewModel은 필요한 데이터를 Model에 요청 합니다.
3. Model은 ViewModel에 필요한 데이터를 응답 합니다.
4. ViewModel은 응답 받은 데이터를 가공해서 저장 합니다.
5. View는 ViewModel과의 Data Binding으로 인해 자동으로 갱신 됩니다.

## Scale Up & Scale Out
![](https://mblogthumb-phinf.pstatic.net/20151124_152/islove8587_1448357175274p9SjR_PNG/tech_img2603.png?type=w210)
### Sacle Up
| | Scale Out | Scale Up |
|:---:|:---:|:---:|
|`확장성`|하나의 장비에서 처리하던 일을 여러 장비에 나눠서 처리할 수 있도록 설계를 변경하는 것. 수평확장. 지속적 확장 가능|더 빠른속도의 CPU로 변경하거나, 더 많은 RAM을 추가하는 등의 하드웨어 장비의 성능을 높이는 것. 수직확장. 성능확장에 한계가 있음.|
|`서버비용`|비용 부담이 적음|비용 부담이 큼|
|`운영비용`|늘어날수록 관리 편의성이 떨어지며 운영비용 증가|큰 변화 없음|
|`장애`|분산처리되어 전면 장애의 가능성이 적음|한대의 서버에 부하 집중되어 장애시 영향 큼|
|`주요기술`|Sharding, Queue, In Memomry Cache, NoSQL, 분산스토리지|고성능 CPU, Memory 확장, SSD|


## Event-driven programming
프로그램의 제어 흐름이 이벤트의 발생에 의해 결정되는 컴퓨터 프로그래밍 패러다임입니다. 

Event-driven 의 구조를 보면 3가지로 분류할 수 있습니다.
- 이벤트를 발생시키는 객체(EventEmitter)
- 이벤트를 관리하는 객체(EventDispatcher): Event이름과 그 이벤트가 발생했을 때 실행해야 할 메소드를 묶어서 관리합니다.
- 이벤트가 발생했을 때 실행되는 객체(EventHandler) :이벤트가 발생했을 때 실제로 실행되는 코드입니다.
